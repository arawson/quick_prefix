#!/bin/bash

# Created by argbash-init v2.5.1
# ARG_OPTIONAL_SINGLE([prefix],[p],[wine prefix location],[$HOME/.wine])
# ARG_OPTIONAL_SINGLE([arch],[a],[wine prefix architecture win32 or win64],[win64])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[print more information])
# ARG_POSITIONAL_SINGLE([exe])
# ARG_HELP([provides a single-command interface to forward environment variables to wine])
# ARG_LEFTOVERS([other arguments are forwarded on to the program])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='pavh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_leftovers=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_prefix="$HOME/.wine"
_arg_arch="win64"
_arg_verbose=off

print_help ()
{
	printf "%s\n" "provides a single-command interface to forward environment variables to wine"
	printf 'Usage: %s [-p|--prefix <arg>] [-a|--arch <arg>] [-v|--(no-)verbose] [-h|--help] <exe> ... \n' "$0"
	printf "\t%s\n" "... : other arguments are forwarded on to the program"
	printf "\t%s\n" "-p,--prefix: wine prefix location (default: '"$HOME/.wine"')"
	printf "\t%s\n" "-a,--arch: wine prefix architecture win32 or win64 (default: '"win64"')"
	printf "\t%s\n" "-v,--verbose,--no-verbose: print more information (off by default)"
	printf "\t%s\n" "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-p|--prefix)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_prefix="$2"
				shift
				;;
			--prefix=*)
				_arg_prefix="${_key##--prefix=}"
				;;
			-p*)
				_arg_prefix="${_key##-p}"
				;;
			-a|--arch)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_arch="$2"
				shift
				;;
			--arch=*)
				_arg_arch="${_key##--arch=}"
				;;
			-a*)
				_arg_arch="${_key##-a}"
				;;
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	_required_args_string="'exe'"
	test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_exe' )
	_our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names+=("_arg_leftovers[$((ii + 0))]")
	done

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

printf 'Value of --%s: %s\n' 'prefix' "$_arg_prefix"
printf 'Value of --%s: %s\n' 'arch' "$_arg_arch"
printf "'%s' is %s\n" 'verbose' "$_arg_verbose"
printf "Value of '%s': %s\n" 'exe' "$_arg_exe"
printf "Value of leftovers %s\n" "${_arg_leftovers[@]}"

# ] <-- needed because of Argbash

if [ "$_arg_verbose" == "on" ]
then
	_wine_debug="warn+all"
fi

_arg_prefix=$(realpath "$_arg_prefix")
echo "$_arg_prefix"

env WINEPREFIX="$_arg_prefix" WINEARCH="$_arg_arch" WINEDEBUG="$_wine_debug" \
wine "$_arg_exe" "${_arg_leftovers[@]}"

